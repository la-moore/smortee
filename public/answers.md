# Вопрос 1
## Фреймворк и стейт-менеджер
---
Обдумывая структуру своего фреймворка, я пришел к выводу, что мне интереснее развивать идею эко-системы из изолированных
библиотек, решающих отдельную проблему лишь при необходимости и связанных между собой единой идеей. Данный подход
позволит создать простой и масштабируемый "фреймворк" для решения практически любых задач.

**Проблема:** Организация кода

Данную проблему нельзя решать точечно, так как она охватывает большую часть написанного кода, поэтому я разбил ее
описание на другие, более конкретные проблемы и описал их решения ниже.

Для точки входа используется основной файл, в котором импортируются необходимые зависимости. При этом основная логика
осуществляется в методе createApp, где фреймворк создает экземпляр приложения с необходимыми параметрами для его запуска.

```javascript
import { createApp } from 'fwx/core'
import { Button } from './button.js'

const app = createApp(Button)

app.mount('#root')
```

**Проблема:** Структура

Каждый элемент, используемый для отрисовки, представляет из себя объект с данными, необходимыми для отрисовки HTML элемента.
При этом компонент не является зависимым от фреймворка, так как его задача лишь в том, чтобы преобразовать входные данные
в объект со всеми данными для будущей отрисовки.

- **render:** метод, возвращающий объект виртуального дерева компонента
- **style:** метод, возвращающий объект стилей для их дальнейшей обработки и встраивания в компонент
- **setup:** метод, возвращающий объект данных, необходимых для отрисовки. Вынесен он в отдельный метод для того, чтобы при создании экземпляра фреймворк мог проанализировать свойства и ,при обнаружении таких зависимостей как реактивность, подписывал рендер данного компонента к обновлениям
- **components:** возвращающий объект с необходимыми для встраивания дочерними компонентами. Вынесен он в отдельный метод для того, чтобы при создании экземпляра фреймворк мог связать зависимости компонентов

```javascript
import { createComponent } from 'fwx/core'
import { html } from 'fwx/render-html'
import { CheckIcon } from '.../icons.js'

export const Button = createComponent({
  components() {
    return {
      CheckIcon
    }
  },

  render(data) {
    const { CheckIcon: CheckIconComponent } = this.components

    return html('div', { class: 'btn' }, [
      CheckIconComponent,
      html('span', {}, [data.msg])
    ])
  },

  style() {
    return {
      color: '#000',
      background: '#ddd',
      padding: '10px 20px',
    }
  },

  setup(props, context) {
    const msg = `Hi, ${props.name}`

    return {
      msg
    }
  }
})
```

**Проблема:** Рендер

Рендер может быть представлен как функция html, так и в любом другом виде. Главная задача рендера в том, чтобы
преобразовать используемое представление тегов в объект, содержащий в себе данные для итогового рендера.

```javascript
import { createComponent } from 'fwx/core'
import { html } from 'fwx/render-html'
import { pug } from 'fwx/render-pug'
import { jsx } from 'fwx/render-jsx'
import { canvas } from 'fwx/render-canvas'

export const ButtonCanvas = createComponent({
  render() {
    return canvas('rect', {})
  }
})

export const ButtonJsx = createComponent({
  render() {
    return jsx('<div>Element</div>')
  }
})

export const ButtonPug = createComponent({
  render() {
    return pug('div Element')
  }
})

export const ButtonHtml = createComponent({
  render() {
    return html('div', {}, ['Element'])
  }
})
```

**Проблема:** Реактивность

Для осуществления автоматического обновления приложения, в зависимости от изменения потока данных, можно использовать
отдельную библиотеку для оборачивания переменных в объекты с геттерами и сеттерами для отслеживания изменений.

Каждое реактивное значение хранит в себе свойства, необходимые для хранения актуального значения, обновления значения,
подписки на обновление и отписки.

- **_value:** хранимое значение
- **value (get):** возвращает актуальное хранимое значение
- **value (set):** обновляет хранимое значение и вызывает методы подписчиков
- **effect.subscribers:** подписчики на обновление
- **effect.subscribe:** метод для подписки на обновление значения
- **effect.unsubscribe:** метод для отмены подписки на обновление значения

```javascript
import { ref, computed } from 'fwx/reactive'
import { createComponent } from 'fwx/core'
import { html } from 'fwx/render-html'

export const ButtonHtml = createComponent({
  render(data) {
    return html('div', {
      onclick: (() => data.name = 'Ben')
    }, [data.msg])
  },

  setup(props, context) {
    const name = ref('Alex')
    
    const msg = computed(() => {
        return `Hi, ${name.value}`
    })

    return {
      name,
      msg
    }
  }
})
```

**Проблема:** Стейт-Менеджер

Для того, чтобы добиться максимально широкого переиспользование кода - удобно разбить сложную бизнес-логику, Стейт-Менеджер
не должен зависеть от компонента или состояния фреймворка. Каждая бизнес-логика (стейт) должна находится в своей
изолированной области видимости, в которую можно импортировать другие бизнес-логики для связки нескольких стейтов, также
каждый стейт должен иметь единую точку выхода, описывающую доступные методы и свойства

```javascript
import { useApi } from '~/services/api.js'
import { useUsers } from '~/states/users.js'
import { useTasks } from '~/states/tasks.js'

const state = {
  prjects: [],
}

function getPrjectTasks(id) {
  const { tasks } = useTasks()

  return //...
}

function fetchPrject(id) {
  const api = useApi()

  return api.get('/rject', { id })
}

function fetchAllPrjects() {
  const { fetch } = useApi()
  
  return //...
}

export default function usePrjects() {
  return {
    prjects: state.prjects,
    fetchPrject,
    fetchAllPrjects,
    getPrjectTasks,
  }
}
```

**Проблема:** Компиляция

Не всегда удобно писать сложные вложенные представления через функции и jsx, поэтому, при необходимости, можно
разработать библиотеку для компиляции, где при импорте файлов `.fwx` или любых других xml файлов в объект компонента, используется:

- `template` в качестве ответа для метода render
- `style` в качестве ответа для метода style
- `script` в качестве ответа для метода setup

<div style="height: 100px;"></div>

## Дополнительно
---

**Проблема:** Разбиение сложной бизнес-логики

Разбивать сложную бизнес логику стоит на максимально маленькие функции в одном или нескольких стейтах, как было описано
в примере стейт-менеджера.

**Проблема:** Организация архитектуры работы с сервером

Для начала необходимо разделить енд-пойнты на условные бизнес-логики (стейты), что позволит грамотно хранить и управлять
данными для конкретной задачи. Например, если у нас есть логика работы с пользователями, то это отдельный стейт со своим
состоянием и своими методами для получения данных. При этом, данный стейт является одной из последних уровней абстракции
в работе с запросами, так как для работы стейта необходим сервис для работы с запросами, который может реализовывать
запросы напрямую в себе через fetch, либо быть лишь оберткой для связи с внешней библиотекой.

```javascript
import { useApi } from '~/services/api.js'

const state = {
  users: [],
}

function fetchUser(id) {
  const api = useApi()

  return api.get('/rject', { id })
}

function fetchUsers() {
  const { fetch } = useApi()
  
  return //...
}

export default function useUsers() {
  return {
    users: state.users,
    fetchUser,
    fetchUsers,
  }
}
```

При необходимости, можно сохранять значения в Local Storage для их обработки в режиме оффлайн.

**Проблема:** Инструменты отладки и тестирования

Для тестирование кода, написанного при помощи фреймворка, необходимо реализовать расширенное api для интеграции с
популярными инструментами тестирования. Данное апи должно учитывать наличие компиляторов и предоставлять возможность
отдельной компиляции компонентов вне приложения.

Для отладки кода, написанного при помощи фреймворка, должна быть реализована библиотека, собирающая информацию о состояния
приложения в реальном времени, анализа виртуального дерева с возможностью просмотра вложенности компонентов и свойств
зависимостей, таких как реактивность и используемые стейты.

Так как документировать и типизировать код это основное правило разработки хорошего инструмента, то для работы над
кодом, написанного при помощи фреймворка, должно быть достаточно использования привычных IDE и поддержкой подсветки
и автокомплита.

Для того, чтобы работали hot reload и time travel в фреймворке, нужно учесть несколько моментов:
- Каждый компонент должен быть прозрачным и никак не воздействовать на другие части кода
- Чистые функции не имеют побочных эффектов и зависят только от информации, явно предоставленной функции, обеспечивая повторяемый, надежный, воспроизводимый путь через код

**Проблема:** Работа в оффлайне

Работа в оффлайне сама по себе сложная задача, так как нужно иметь очень хорошее понимание того, что действительно должно
работать в оффлайне, чтобы не запутать конечного пользователя, ведь любому человеку, будет не очень понятно что в данный
момент у него отключилась сеть в метро но при этом он получает старые данные из кэша.

Мое мнение заключается в том, что работать в оффлайне должно само приложение, но не работа с данными. Это означает, что
кэшировать необходимо лишь файлы, необходимые для отрисовки, данное решение увеличивает сложность разработки интерфейсов,
так как необходимо многим компонентам добавить логику обработки состояния в оффлайне и отображения заглушек ожидающих
подключение к сети, данное ожидание можно реализовать через пинг сервера и ожидания ответа, либо через сервис, в котором
хранится информация о подключении.

```javascript
const state = {
  connected: true,
}

function initConnection() {
  window.addEventListener('online', (event) => {
    state.connected = true
  })

  window.addEventListener('offline', (event) => {
    state.connected = false
  })
}

function fetchUsers() {
    
}

export default function useConnection() {
  return {
    connected: state.connected,
    initConnection,
  }
}
```

Не смотря на это мнение, есть задачи, в которых уместно использование кэша и для запросов, в данном случае, можно создать
Service Worker для кэширования необходимых запросов. Описывать работу Service Worker`ов думаю излишне, об этом и так
много статей.

<div style="height: 100px;"></div>

# Вопрос 2
## Фризы и снижения FPS
---

**Проблема:** Медленный хостинг

Проверить показатели скорости загрузки сайта в отчете из доступных сервисов, например Google Analytics или
PageSpeed Insights.

Если замечено высокое ожидание от хостинга, то стоит задуматься о переносе приложения на более быстрый хостинг.

**Проблема:** Долгий ответ сервера

Проверить скорость получения ответа от сервера на запросы, выполняющиеся в момент фризов.

Если замечено высокое ожидание от сервера, необходимо уведомить об этом команду, ответственную за разработку сервера и
уточнить, какие есть варианты для ускорения работы долгих запросов, например, использование технологии кэширования.

**Проблема:** Большие размеры приложения

Проверить, разбивается ли приложение на чанки, если да, то какие размеры этих чанков и в какой момент происходит их
загрузка.

Если замечено, что приложение не разбивается, то следует вынести отдельные части приложения в чанки.

Если замечено, что приложение разбито на большие чанки, следует разбить приложение на чанки небольшого размера, чтобы
обеспечить более быструю загрузку отдельных частей приложения и обеспечить правильную цепочку загрузки.

Если замечено, что приложение ожидает получение всех чанков перед запуском, следует проверить на сколько это необходимо
и, если есть возможность, вынести ненужные для запуска чанки в ленивую загрузку.

**Проблема:** Изображения высокого качества

Все изображения еще на этапе подготовки проекта следует оптимизировать для работы с сайтом, есть доступные варианты
в виде `image-minimizer` и `image-resizer`, настроив данные библиотеки, можно оптимизировать все используемые
изображения на фронте во время билда.

**Проблема:** Сложный рендер

Некоторые свойства CSS значительно тяжелее других, поэтому их следует использовать очень аккуратно,
например: `border-radius`, `box-shadow`, `filter`, `:nth-child`, `position: fixed;`, `transform`.

Можно использовать `translateZ(0)` для того, чтобы отрисовать элементы в GPU еще до того, как анимация началась.
transform работают напрямую с GPU памятью, которая использует аппаратное ускорение.

Уменьшение количества узлов (node) в DOM tree. Чем меньше DOM элементов нужно отрисовать, тем быстрее движок их отрисует.

**Проблема:** Блокирование Event Loop

Проверить показатели вкладки `Performance` в консоли и таски, на обработку которых было потрачено много времени.

Если замечена задача. требующая много времени для обработки, стоит проверить задачу и, если есть возможность, разбить ее
на более мелкие задачи для того, чтобы не блокировать рендер и обработку событий.

<div style="height: 100px;"></div>

## Фикс - Код фризит страницу на 30 секунд
---

```javascript
var bigJSON = unzip(manyBytesFromLocalStorage)
var html = ''

for ( i of bigJSON ) {
  html += renderHTML(i)
}

ul.innerHTML = html
```

Для решения данной проблемы фриза страницы на 30 секунд, я могу предложить несколько шагов:

- Переделать forOf на простой for или, как я написал в примере, на разбитые задачи через setTimeout
- Вынести сложные функции в setTimeout, чтобы дождаться выполнения всех задач до запуска сложной функции
- Обновлять DOM при каждой итерации, а не весь результат за один раз
- ^ Я бы вынес `unzip(manyBytesFromLocalStorage)` в worker, чтобы можно было обработать его в параллельный поток
- ^ Я бы задумался над использованием библиотеки на подобии GPU.js для того, чтобы передавать выполнение сложных функций на ресурсы GPU

В данном примере я постарался максимально улучшить производительность без сторонних инструментов, не уверен, что
лучший вариант решения проблемы, но данный подход не мешает рендеру и не фризит просмотр страницы.

```javascript
// Данная обертка позволяет разделить каждую итерацию forOf на отдельные задачи, чтобы не блокировать EventLoop
const initTask = (data) => {

  /* 
  * Выполнить цикл, используя аргументы:
  * @i - итерация в данный момент
  * @chunkLimit - число итерации за один таск
  * @target - общее количество итерации
  */
	function subTask(i = 0, chunkLimit = 0, target = 0) {
		let cbl = Math.min(i + chunkLimit, target)

		while(i < cbl) {
			// Обновлять DOM при каждой итерации ускорит рендер, так как результат будет отрисовываться по кусочкам
			document.body.innerHTML += renderHTML(data[i])

			i++
		}

	  if (i < target) {
	    setTimeout(subTask, 0, i, chunkLimit, target)
	  } else {
	  	console.log('Render Finished')
	  }
	}

	subTask(0, 1, data.length)
}

// Использовать timeout для того, чтобы выбросить функцию в конец очереди
const init = () => setTimeout(() => {
	const data = unzip(manyBytesFromLocalStorage)

	initTask(data)
})

// Вынести сложную функцию в отдельную функцию-обертку и вызывать только при необходимости
init()
```

<div style="height: 100px;"></div>

# Вопрос 3
## Технологии в браузерах и опенсорс-сообщества
---

**Вспомогательная очередь**

Было бы здорово получить доступ из основного исполняемого файла к дополнительной очереди для выполнения сложных задач
в потоке, не мешающему основному потоку, как это реализовано, например, с worker.

**Полноценные веб-компоненты**

Имеющаяся реализация веб-компонентов довольно сложная и громоздкая. Некоторые мои замечания:
- Активация Shadow DOM в каждом компоненте такое себе.
- Сложная работа с Shadow DOM при необходимости внедрения стилей и скриптов.
- Проблемы с типизацией
- Атрибуты — только строчные значения
- Изоляция стилей
